`timescale 1ns / 1ps

`include "vppc_macros.sv"
`ifdef SIMULATION_DAQ
    `include "spbits.sv"
`endif
// neural net tux, IOs are matching SP core
module nn_tux
(
    // precise phi and theta of best tracks
    // [best_track_num]
    input [bw_fph-1:0] bt_phi [2:0],
    input [bw_th-1:0]  bt_theta [2:0],
    // [best_track_num][station]
    input [3:0]        bt_cpattern [2:0][3:0],
    // ph and th deltas from best stations
    // [best_track_num], last index: 0=12, 1=13, 2=14, 3=23, 4=24, 5=34
    input [bw_fph-1:0] bt_delta_ph [2:0][5:0],
    input [bw_th-1:0]  bt_delta_th [2:0][5:0], 
    input [5:0]        bt_sign_ph[2:0],
    input [5:0]        bt_sign_th[2:0],
    // ranks [best_track_num]
    input [bwr:0]      bt_rank [2:0],
    // segment IDs
    // [best_track_num][station 0-3]
    input [seg_ch-1:0] bt_vi [2:0][4:0], // valid
    input [1:0]        bt_hi [2:0][4:0], // bx index
    input [3:0]        bt_ci [2:0][4:0], // chamber
    input [4:0]        bt_si [2:0], // segment
    
    output reg [7:0] pt_out [2:0],
    output reg [2:0] pt_valid,
    output reg [2:0] d0_out [2:0],
    output reg [2:0] d0_valid,
    // clock
    input                 clk,
    
    input endcap,
    input [2:0] sector

);
`include "spbits.sv"

    // convert patterns into bend angles
    // message from Sergo 2022-01-20
    // note that the output bend angle is not the same as bend angle reported by new TMB firmware
    wire [17:0] bt_bend [2:0][3:0];
    reg  [17:0] bt_bend_r [2:0][3:0];
    logic clk_120;
    genvar gi, gj;
    generate
        for (gi = 0; gi < 3; gi++) // best track loop
        begin
            for (gj = 0; gj < 4; gj++) // station loop
            begin
                pat_2_bend p2b 
                (
                    .endcap  (endcap), 
                    .pattern (bt_cpattern [gi][gj]),
                    .bend    (bt_bend     [gi][gj])
                );                
            end
        end
    endgenerate

    integer i, j;
    

    logic vb_re1, vb_re2, vb_re3, vb_re4;
    
    // front-rear LUTs
    // [sector[0]][station 0-4][chamber id]
    reg [12:0] fr [1:0][4:0];
    // fr contents comes from FRLUT.cc generated by M. Carver on 2015-10-15
    // reversed bit order, added neighbor sector stations
    // chamber numbers start from 1, so add an extra low bit for invalid chamber = 0 
    assign fr [0][0] = 13'b011000010010_0;
    assign fr [0][1] = 13'b000000101101_0;
    assign fr [0][2] = 13'b010101010101_0;
    assign fr [0][3] = 13'b001010101010_0;
    assign fr [0][4] = 13'b001010101010_0;
    
    assign fr [1][0] = 13'b011000010010_0;
    assign fr [1][1] = 13'b000000101101_0;
    assign fr [1][2] = 13'b011101010010_0;
    assign fr [1][3] = 13'b000010101101_0;
    assign fr [1][4] = 13'b000010101101_0;
    
    logic [3:0] mode [2:0];
    logic [2:0] stA [2:0];
    logic [2:0] bt_stA [2:0];
    logic [3:0] chA [2:0];
    logic [2:0] ring1_0;
    logic [5:0] delta_valid [2:0];
    
    reg signed [17:0]  bt_delta_ph_r [2:0][5:0]; // these are signed 2's complements converted from regular deltas
    reg signed [17:0]  bt_delta_th_r [2:0][5:0]; // these are signed 2's complements converted from regular deltas
    reg signed [17:0]  bt_delta_ph_s [2:0][5:0]; // these are signed 2's complements converted from regular deltas
    reg signed [17:0]  bt_delta_th_s [2:0][5:0]; // these are signed 2's complements converted from regular deltas
    reg [bw_th-1:0]    bt_theta_r [2:0];
    reg [3:0]          bt_cpattern_r [2:0][3:0];
    logic [17:0] input1_V [22:0];
    logic [11:0] layer11_out_0_V;
    logic layer11_out_0_V_ap_vld;
    logic [11:0] layer11_out_1_V;
    logic layer11_out_1_V_ap_vld;


    logic [1:0] mux_phase = 2'h0;
    logic [1:0] mux_phase_out [2:0] = '{2'd0, 2'd1, 2'd2}; // output multiplexor depends on exact NN latency, needs rework if latency changes 
    logic [1:0] clk_hist;
    
    // conversion LUTs according to Sergo's message from 2021-09-22
    // separate LUT for each best track
    // [best_track_num][location]
    reg [7:0] pt_lut_0[2047:0];
    reg [2:0] d0_lut_0[2047:0];
    reg [7:0] pt_lut_1[2047:0];
    reg [2:0] d0_lut_1[2047:0];
    reg [7:0] pt_lut_2[2047:0];
    reg [2:0] d0_lut_2[2047:0];
    reg [11:0] pt_unconv [2:0];
    reg [11:0] d0_unconv [2:0];
    reg [2:0] pt_unconv_valid;
    reg [2:0] fri;
    
    localparam NN_LATENCY = 4;
    reg [2:0] valid_in [NN_LATENCY-1:0];

    always @(*)
    begin


        for (i = 0; i < 3; i++) // best track loop
        begin
            mode[i] = {bt_rank[i][5], bt_rank[i][3], bt_rank[i][1], bt_rank[i][0]};
            // find valid chamber ID from station 1
            case (mode[i])
                 4'd1:  begin stA[i] = 3'h0; delta_valid[i] = 6'b000000; end // single hit trigger 
                 4'd12: begin stA[i] = 3'h0; delta_valid[i] = 6'b000001; end // 1-2
                 4'd10: begin stA[i] = 3'h0; delta_valid[i] = 6'b000010; end // 1-3
                 4'd9:  begin stA[i] = 3'h0; delta_valid[i] = 6'b000100; end // 1-4
                 4'd6:  begin stA[i] = 3'h1; delta_valid[i] = 6'b001000; end // 2-3
                 4'd5:  begin stA[i] = 3'h1; delta_valid[i] = 6'b010000; end // 2-4
                 4'd3:  begin stA[i] = 3'h2; delta_valid[i] = 6'b100000; end // 3-4
                 4'd14: begin stA[i] = 3'h0; delta_valid[i] = 6'b001111; end // 1-2-3
                 4'd13: begin stA[i] = 3'h0; delta_valid[i] = 6'b010101; end // 1-2-4
                 4'd11: begin stA[i] = 3'h0; delta_valid[i] = 6'b100110; end // 1-3-4
                 4'd7:  begin stA[i] = 3'h1; delta_valid[i] = 6'b111000; end // 2-3-4
                 4'd15: begin stA[i] = 3'h0; delta_valid[i] = 6'b111111; end // 1-2-3-4
                 default: begin stA[i] = 3'h0; delta_valid[i] = 6'b000000; end
            endcase            
    
            if (stA[i] == 3'h0 && bt_vi[i][0] != 2'b0)
            begin
                bt_stA[i] = stA[i];
                chA[i] = bt_ci[i][0];
            end
            else
            begin
                bt_stA[i] = stA[i] + 3'h1;
                chA[i] = bt_ci[i][bt_stA[i]];
            end
            
            ring1_0[i] = 1'b1;
            if (
                (bt_vi[i][0][0] == 1'b1 && bt_ci[i][0] <= 4'd2) ||
                (bt_vi[i][1][0] == 1'b1 && bt_ci[i][1] <= 4'd2)    // station 1 valid and CSCID = 1,2,3 means ME1/1
            ) 
            begin
                ring1_0[i] = 1'b0;
            end  
            
            fri[i] = fr [sector[0]][bt_stA[i]][chA[i]];
        end      
    end
    
    reg clk40_ff = 1'b0;
    always @(posedge clk)
    begin 
        clk40_ff = ~clk40_ff;

        pt_valid = valid_in[NN_LATENCY-1]; // converted value valid
        d0_valid = valid_in[NN_LATENCY-1];
        
        // delay line for valid input signal matching NN latency
        // output is used as valid output flags, since NN does not provide any "valid" output flag
        for (i = NN_LATENCY-2; i >= 0; i--)
        begin
            valid_in[i+1] = valid_in[i];
        end

        valid_in[0] = 3'b0;
        for (i = 0; i < 3; i++)
        begin
            if 
            (
                mode[i] != 4'b0000  && 
                mode[i] != 4'b0001  && 
                mode[i] != 4'b0010  && 
                mode[i] != 4'b0100  && 
                mode[i] != 4'b1000 
            )
                valid_in[0][i] = 1'b1; // if more than one station detected, inputs valid
        end

    end
    
    always @(posedge clk_120)
    begin

        if (clk_hist[0] != clk_hist[1]) // 40 M clk just rose
            mux_phase = 2'h0; // reset multiplexor phase
        else
            mux_phase++;

        // adding delays to prevent issues in simulation
        clk_hist[1] = #1 clk_hist[0];
        clk_hist[0] = #1 clk40_ff;
    
    end

    emtfptnn pt_nn 
    (
        .ap_clk (clk_120),
        .ap_rst (1'b0),
        .ap_start (1'b1),
        .ap_done (),
        .ap_idle (),
        .ap_ready (),
        
        .input1_0_V  (bt_delta_ph [mux_phase][0]),
        .input1_1_V  (bt_delta_ph [mux_phase][1]),
        .input1_2_V  (bt_delta_ph [mux_phase][2]),
        .input1_3_V  (bt_delta_ph [mux_phase][3]),
        .input1_4_V  (bt_delta_ph [mux_phase][4]),
        .input1_5_V  (bt_delta_ph [mux_phase][5]),
        .input1_6_V  (bt_sign_ph  [mux_phase][0]),
        .input1_7_V  (bt_sign_ph  [mux_phase][1]),
        .input1_8_V  (bt_sign_ph  [mux_phase][2]),
        .input1_9_V  (bt_sign_ph  [mux_phase][3]),
        .input1_10_V (bt_sign_ph  [mux_phase][4]),
        .input1_11_V (bt_sign_ph  [mux_phase][5]),
        .input1_12_V (bt_delta_th [mux_phase][0]),
        .input1_13_V (bt_delta_th [mux_phase][1]),
        .input1_14_V (bt_delta_th [mux_phase][2]),
        .input1_15_V (bt_delta_th [mux_phase][3]),
        .input1_16_V (bt_delta_th [mux_phase][4]),
        .input1_17_V (bt_delta_th [mux_phase][5]),
        .input1_18_V (bt_sign_th  [mux_phase][0]),
        .input1_19_V (bt_sign_th  [mux_phase][1]),
        .input1_20_V (bt_sign_th  [mux_phase][2]),
        .input1_21_V (bt_sign_th  [mux_phase][3]),
        .input1_22_V (bt_sign_th  [mux_phase][4]),
        .input1_23_V (bt_sign_th  [mux_phase][5]),
        .input1_24_V (bt_cpattern [mux_phase][0]),
        .input1_25_V (bt_cpattern [mux_phase][1]),
        .input1_26_V (bt_cpattern [mux_phase][2]),
        .input1_27_V (bt_cpattern [mux_phase][3]),
        .input1_28_V (fri         [mux_phase]),
        .input1_29_V (bt_theta    [mux_phase]),
        .input1_30_V (ring1_0     [mux_phase]),
        .layer12_out_0_V (PT),
        .layer12_out_1_V (dXY)
    );

    nn_mmcm nnmcmc
    (
        .clk_out1(clk_120),
        .reset(1'b0),
        .locked(),
        .clk_in1(clk)
    );


endmodule
